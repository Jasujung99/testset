<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>알고리즘 성운 (Algorithm Nebula)</title>
    <!-- React, Babel, Vega 라이브러리 로드 -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Vega 및 Vega-Embed 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/vega@5.22.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@5.6.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.21.0"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">    <style>
        :root {
            --bg-deep-space: #0c0a1a;
            --bg-space: #111827;
            --bg-nebula: #1f2937;
            --text-primary: #e5e7eb;
            --text-secondary: #9ca3af;
            --accent-purple: #818cf8;
            --accent-blue: #60a5fa;
            --accent-yellow: #facc15;
            --accent-red: #f87171;
            --accent-green: #4ade80;
        }
        body { 
            font-family: 'Noto Sans KR', sans-serif; 
            background-color: var(--bg-deep-space);
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            margin: 0;
        }
        .app-wrapper {
            width: 100%;
            max-width: 1400px;
            background-color: var(--bg-space);
            border-radius: 16px;
            padding: 2rem;
            border: 1px solid #374151;
            box-shadow: 0 0 50px -10px rgba(129, 140, 248, 0.2);
        }
        .header { text-align: center; margin-bottom: 1.5rem; }
        .title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(90deg, var(--accent-purple), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: var(--text-secondary);
            font-size: 1.125rem;
            margin-bottom: 2rem;
        }        
        .vis-container {
            position: relative;
            background: radial-gradient(circle, #2d3748 0%, var(--bg-deep-space) 70%);
            min-height: 60vh;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .controls-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            background-color: var(--bg-deep-space);
            padding: 1rem;
            border-radius: 8px;
        }
        .control-section { display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }        .button, .algo-button {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #374151;
            color: var(--text-primary);
            font-weight: 500;
        }
        .button:hover, .algo-button:hover {
            background-color: #4b5563;
            transform: translateY(-1px);
        }
        .algo-button.active {
            background-color: var(--accent-purple);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px -5px rgba(129, 140, 248, 0.4);
        }
        .slider-container { display: flex; align-items: center; gap: 0.5rem; color: var(--text-secondary); font-size: 0.9rem; }
        .slider { accent-color: var(--accent-purple); }
        .slider-value { color: var(--text-primary); font-weight: 700; min-width: 25px; }        .primary-button { background-color: var(--accent-purple); color: white; }
        .primary-button.running { background-color: var(--accent-red); }
        .secondary-button { background-color: #4b5563; }
          .actions { 
            display: flex; 
            justify-content: center; 
            gap: 1rem; 
            margin-top: 1.5rem; 
        }
        
        .main-layout { 
            display: grid; 
            grid-template-columns: 1fr; 
            gap: 1.5rem; 
            margin-bottom: 1.5rem; 
        }
        @media (min-width: 768px) {
            .main-layout { 
                grid-template-columns: 3fr 1fr; 
            }
        }
        .info-card-wrapper { 
            background-color: var(--bg-nebula); 
            padding: 1.5rem; 
            border-radius: 8px; 
        }
        .info-title { 
            font-size: 1.5rem; 
            font-weight: 700; 
            color: var(--accent-blue); 
            margin-bottom: 1rem; 
        }
        .info-timer { 
            margin-bottom: 1rem; 
            font-size: 1.1rem; 
            color: var(--text-secondary); 
        }
        .timer-value { 
            font-weight: 700; 
            color: var(--accent-yellow); 
            font-family: monospace; 
        }
        .info-heading { 
            font-weight: 700; 
            color: var(--text-primary); 
            border-left: 3px solid var(--accent-blue); 
            padding-left: 0.75rem; 
            margin-bottom: 0.5rem; 
        }
        .info-text { 
            color: var(--text-secondary); 
            font-size: 0.9rem; 
            margin-bottom: 1rem; 
        }
        
        /* 기존 개별 스타일 */
        
        /* 알고리즘 버튼 스타일 */
        .algo-btn {
            position: relative;
            overflow: visible;
        }
        
        .complexity-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 0.7rem;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .algo-btn:hover .complexity-badge,
        .algo-btn.active .complexity-badge {
            opacity: 1;
            transform: scale(1);
        }
        
        /* 배열 시각화 */
        .array-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            max-width: 90%;
            overflow-x: auto;
        }
        
        .array-item {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            font-family: monospace;
            transition: all 0.3s ease;
        }
          .array-item.default { 
            background-color: rgba(96, 165, 250, 0.7); 
            box-shadow: 0 2px 4px rgba(96, 165, 250, 0.3);
            transition: all 0.3s ease;
        }
        
        .array-item.comparing { 
            background-color: rgba(248, 113, 113, 0.9);
            transform: translateY(-4px);
            box-shadow: 0 4px 8px rgba(248, 113, 113, 0.4);
            border: 2px solid rgba(248, 113, 113, 0.8);
        }
        
        .array-item.swapped { 
            background-color: rgba(250, 204, 21, 0.9);
            transform: translateY(-2px) scale(1.1);
            box-shadow: 0 4px 8px rgba(250, 204, 21, 0.4);
            border: 2px solid rgba(250, 204, 21, 0.8);
        }
        
        .array-item.pivot { 
            background-color: rgba(129, 140, 248, 0.9);
            box-shadow: 0 4px 8px rgba(129, 140, 248, 0.4);
            border: 3px solid rgba(129, 140, 248, 1);
            transform: scale(1.05);
        }
        
        .array-item.sorted { 
            background-color: rgba(74, 222, 128, 0.9);
            box-shadow: 0 4px 8px rgba(74, 222, 128, 0.4);
            border: 2px solid rgba(74, 222, 128, 0.6);
        }
        
        .array-item.min { 
            background-color: rgba(167, 139, 250, 0.9);
            box-shadow: 0 4px 8px rgba(167, 139, 250, 0.4);
            border: 2px solid rgba(167, 139, 250, 0.8);
            transform: scale(1.03);
        }
        
        .array-item.key { 
            background-color: rgba(251, 146, 60, 0.9);
            box-shadow: 0 4px 8px rgba(251, 146, 60, 0.4);
            border: 2px solid rgba(251, 146, 60, 0.8);
            transform: scale(1.03);
        }
        
        .array-item.merged { 
            background-color: rgba(52, 211, 153, 0.9);
            animation: fadeIn 0.5s;
            box-shadow: 0 4px 8px rgba(52, 211, 153, 0.4);
            border: 2px solid rgba(52, 211, 153, 0.6);
        }
          @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        /* 향상된 애니메이션 효과들 */
        @keyframes pulse {
            0% { 
                transform: translateY(-4px) scale(1); 
                box-shadow: 0 4px 8px rgba(248, 113, 113, 0.4);
            }
            100% { 
                transform: translateY(-6px) scale(1.05); 
                box-shadow: 0 6px 12px rgba(248, 113, 113, 0.6);
            }
        }
        
        @keyframes bounce {
            0% { 
                transform: translateY(-2px) scale(1.1); 
            }
            25% { 
                transform: translateY(-8px) scale(1.15); 
            }
            50% { 
                transform: translateY(-2px) scale(1.1); 
            }
            75% { 
                transform: translateY(-4px) scale(1.12); 
            }
            100% { 
                transform: translateY(-2px) scale(1.1); 
            }
        }
        
        @keyframes glow {
            0% { 
                box-shadow: 0 4px 8px rgba(129, 140, 248, 0.4);
                transform: scale(1);
            }
            100% { 
                box-shadow: 0 6px 16px rgba(129, 140, 248, 0.8), 0 0 20px rgba(129, 140, 248, 0.4);
                transform: scale(1.02);
            }
        }
        
        @keyframes fadeInScale {
            0% { 
                opacity: 0; 
                transform: scale(0.8); 
            }
            50% { 
                opacity: 0.7; 
                transform: scale(1.1); 
            }
            100% { 
                opacity: 1; 
                transform: scale(1); 
            }
        }
        
        @keyframes staggeredEntry {
            0% { 
                opacity: 0; 
                transform: translateY(10px) scale(0.9); 
            }
            100% { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }
          #vega-vis {
            width: 100%;
            height: 100%;
        }
        
        /* 반응형 스타일 */
        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            .subtitle {
                font-size: 1rem;
            }
            .algo-button {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            .controls-group {
                gap: 0.5rem;
            }
            .control-section {
                gap: 0.3rem;
            }
            .array-item {
                width: 24px;
                height: 24px;
                font-size: 11px;
            }
            .info-title {
                font-size: 1.2rem;
            }
            .app-wrapper {
                padding: 1rem;
            }
        }
        
        /* 애니메이션 개선 */
        .app-wrapper {
            animation: fadeInUp 0.6s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .vis-container {
            transition: all 0.3s ease;
        }
        
        /* 호버 효과 개선 */
        .button:hover, .algo-button:hover {
            box-shadow: 0 2px 8px rgba(129, 140, 248, 0.3);
        }
        
        .info-card-wrapper {
            transition: all 0.3s ease;
            border: 1px solid rgba(129, 140, 248, 0.1);
        }
        
        .info-card-wrapper:hover {
            border-color: rgba(129, 140, 248, 0.3);
            box-shadow: 0 4px 20px rgba(129, 140, 248, 0.1);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        function runApp() {
            const { useState, useEffect, useRef, useCallback } = React;
            const N = 25; // 데이터 포인트 수
              // 알고리즘 정보 - 우주 테마
            const algoInfo = {
                bubble: { 
                    title: '중력파 정렬 (Gravitational Wave Sort)', 
                    concept: '이웃한 두 행성을 비교하여 질량(값)이 잘못되었을 경우 서로의 궤도를 바꿉니다. 이 과정이 반복되며 가장 무거운 행성이 바깥 궤도로 밀려납니다.',
                    color: '#3C6CDF',
                    complexity: 'O(n²)',
                    bgClass: 'primary'
                },
                selection: { 
                    title: '항성 형성 (Stellar Formation Sort)', 
                    concept: '성운 전체에서 가장 무거운 행성을 찾아 가장 바깥 궤도에 고정시킵니다. 이 과정을 반복하며 안쪽으로 궤도를 채워나갑니다.',
                    color: '#8A4FFF',
                    complexity: 'O(n²)',
                    bgClass: 'secondary'
                },
                insertion: { 
                    title: '궤도 동기화 (Orbital Synchronization Sort)', 
                    concept: '하나의 행성을 선택해, 이미 정렬된 안쪽 궤도의 행성들과 비교하며 자신의 올바른 궤도를 찾아 삽입됩니다.',
                    color: '#F5597F',
                    complexity: 'O(n²)',
                    bgClass: 'danger'
                },
                merge: { 
                    title: '성운 병합 (Nebula Merge Sort)', 
                    concept: '성운을 계속 절반으로 나누어 최소 단위(행성 하나)로 분해한 뒤, 다시 두 성운씩 질량 순서에 맞게 병합하며 전체를 정렬합니다.',
                    color: '#57CBFF',
                    complexity: 'O(n log n)',
                    bgClass: 'info'
                },
                quick: { 
                    title: '퀘이사 피벗 (Quasar Pivot Sort)', 
                    concept: '성운에서 임의의 기준 행성(피벗)을 선택하고, 그보다 가벼운 행성들은 안쪽, 무거운 행성들은 바깥쪽으로 재배치합니다. 이 과정을 분할된 각 영역에서 반복합니다.',
                    color: '#FCBB4A',
                    complexity: 'O(n log n)',
                    bgClass: 'warning'
                }
            };

            // 버블 정렬
            function* bubbleSort(arr) { 
                let a = JSON.parse(JSON.stringify(arr)); 
                for(let i = 0; i < a.length; i++) { 
                    for (let j = 0; j < a.length - i - 1; j++) { 
                        a.forEach(d => { if(d.state !== 'sorted') d.state = 'default'; });
                        a[j].state = 'comparing'; 
                        a[j+1].state = 'comparing';
                        yield [...a];
                        
                        if (a[j].value > a[j+1].value) {
                            const temp = {...a[j]};
                            a[j] = {...a[j+1]};
                            a[j+1] = temp;
                            a[j].state = 'swapped';
                            a[j+1].state = 'swapped';
                            yield [...a];
                        }
                    }
                    a[a.length - i - 1].state = 'sorted';
                }
                a.forEach(d => d.state = 'sorted');
                return [...a];
            }
            
            // 선택 정렬
            function* selectionSort(arr) { 
                let a = JSON.parse(JSON.stringify(arr)); 
                for(let i = 0; i < a.length - 1; i++) { 
                    let min_idx = i; 
                    a.forEach((d, k) => d.state = k < i ? 'sorted' : 'default');
                    a[min_idx].state = 'min';
                    yield [...a];
                    
                    for(let j = i + 1; j < a.length; j++) {
                        a[j].state = 'comparing';
                        yield [...a];
                        
                        if (a[j].value < a[min_idx].value) {
                            a[min_idx].state = 'default';
                            min_idx = j;
                            a[min_idx].state = 'min';
                            yield [...a];
                        } else {
                            a[j].state = 'default';
                        }
                    }
                    
                    if (min_idx !== i) {
                        const temp = {...a[i]};
                        a[i] = {...a[min_idx]};
                        a[min_idx] = temp;
                        a[i].state = 'sorted';
                        yield [...a];
                    }
                    a[i].state = 'sorted';
                }
                a[a.length - 1].state = 'sorted';
                return [...a];
            }
            
            // 삽입 정렬
            function* insertionSort(arr) {
                let a = JSON.parse(JSON.stringify(arr));
                for (let i = 1; i < a.length; i++) {
                    a.forEach((d, k) => d.state = k < i ? 'sorted' : 'default');
                    a[i].state = 'key';
                    yield [...a];
                    
                    let key = {...a[i]};
                    let j = i - 1;
                    
                    while (j >= 0 && a[j].value > key.value) {
                        a[j].state = 'comparing';
                        a[j + 1].state = 'comparing';
                        yield [...a];
                        
                        a[j + 1] = {...a[j]};
                        a[j + 1].state = 'swapped';
                        yield [...a];
                        j--;
                    }
                    a[j + 1] = key;
                    a[j + 1].state = 'sorted';
                    yield [...a];
                }
                a.forEach(d => d.state = 'sorted');
                return [...a];
            }
            
            // 병합 정렬
            function* mergeSort(arr) {
                let a = JSON.parse(JSON.stringify(arr));
                yield* mergeSortHelper(a, 0, a.length - 1);
                a.forEach(d => d.state = 'sorted');
                return [...a];
            }
            
            function* mergeSortHelper(arr, left, right) {
                if (left >= right) return;
                
                const mid = Math.floor((left + right) / 2);
                yield* mergeSortHelper(arr, left, mid);
                yield* mergeSortHelper(arr, mid + 1, right);
                yield* merge(arr, left, mid, right);
            }
            
            function* merge(arr, left, mid, right) {
                const leftArr = arr.slice(left, mid + 1);
                const rightArr = arr.slice(mid + 1, right + 1);
                
                let i = 0, j = 0, k = left;
                
                while (i < leftArr.length && j < rightArr.length) {
                    arr.forEach(d => d.state = 'default');
                    arr[k].state = 'comparing';
                    yield [...arr];
                    
                    if (leftArr[i].value <= rightArr[j].value) {
                        arr[k] = {...leftArr[i]};
                        i++;
                    } else {
                        arr[k] = {...rightArr[j]};
                        j++;
                    }
                    arr[k].state = 'merged';
                    k++;
                    yield [...arr];
                }
                
                while (i < leftArr.length) {
                    arr[k] = {...leftArr[i]};
                    arr[k].state = 'merged';
                    i++;
                    k++;
                    yield [...arr];
                }
                
                while (j < rightArr.length) {
                    arr[k] = {...rightArr[j]};
                    arr[k].state = 'merged';
                    j++;
                    k++;
                    yield [...arr];
                }
            }
            
            // 퀵 정렬
            function* quickSort(arr) {
                let a = JSON.parse(JSON.stringify(arr));
                yield* quickSortHelper(a, 0, a.length - 1);
                a.forEach(d => d.state = 'sorted');
                return [...a];
            }
            
            function* quickSortHelper(arr, low, high) {
                if (low < high) {
                    const pivotIndex = yield* partition(arr, low, high);
                    yield* quickSortHelper(arr, low, pivotIndex - 1);
                    yield* quickSortHelper(arr, pivotIndex + 1, high);
                }
            }
            
            function* partition(arr, low, high) {
                arr.forEach(d => d.state = 'default');
                const pivot = arr[high];
                pivot.state = 'pivot';
                yield [...arr];
                
                let i = low - 1;
                
                for (let j = low; j < high; j++) {
                    arr[j].state = 'comparing';
                    yield [...arr];
                    
                    if (arr[j].value < pivot.value) {
                        i++;
                        if (i !== j) {
                            [arr[i], arr[j]] = [arr[j], arr[i]];
                            arr[i].state = 'swapped';
                            arr[j].state = 'swapped';
                            yield [...arr];
                        }
                    }
                    arr[j].state = 'default';
                }
                
                [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                arr[i + 1].state = 'pivot';
                yield [...arr];
                
                return i + 1;
            }
            
            const sortGenerators = { 
                bubble: bubbleSort, 
                selection: selectionSort,
                insertion: insertionSort,
                merge: mergeSort,
                quick: quickSort
            };

            // Vega 시각화 컴포넌트
            const VegaVisualization = ({ data, algorithm }) => {
                const containerRef = useRef();
                const vegaRef = useRef(null);
                  // Vega 스펙 생성 함수
                const createVegaSpec = useCallback((dataset) => {
                    // 동적 크기 계산 (컨테이너 크기에 맞춤)
                    const containerWidth = 600;
                    const containerHeight = 500;
                    const center = Math.min(containerWidth, containerHeight) / 2;                    // 상태에 따른 색상 매핑 - 개선된 우주 테마 색상 (그라데이션 효과)
                    const colorMap = {
                        'default': { fill: '#60a5fa', stroke: '#3b82f6' },      // 블루 (기본 행성)
                        'comparing': { fill: '#f87171', stroke: '#ef4444' },    // 레드 (비교 중)
                        'swapped': { fill: '#facc15', stroke: '#eab308' },      // 옐로우 (교환됨)
                        'sorted': { fill: '#4ade80', stroke: '#22c55e' },       // 그린 (정렬됨)
                        'min': { fill: '#a78bfa', stroke: '#8b5cf6' },          // 퍼플 (최솟값)
                        'key': { fill: '#fb923c', stroke: '#f97316' },          // 오렌지 (키 값)
                        'pivot': { fill: '#818cf8', stroke: '#6366f1' },        // 인디고 (피벗)
                        'merged': { fill: '#34d399', stroke: '#10b981' }        // 에메랄드 (병합됨)
                    };
                    
                    // 개선된 행성 배치 알고리즘
                    // 궤도 정렬 방식으로 변경 (더 균일한 분포)
                    const maxRadius = center * 0.75; // 가용 공간을 조금 더 활용
                    
                    // 각 행성 유형별 특성 정의
                    const planetStyles = {
                        'default': { 
                            strokeWidth: 1.5, 
                            pattern: 'plain'
                        },
                        'comparing': { 
                            strokeWidth: 2, 
                            pattern: 'ripple',
                            glow: true
                        },
                        'swapped': { 
                            strokeWidth: 2, 
                            pattern: 'swirl',
                            glow: true 
                        },
                        'sorted': { 
                            strokeWidth: 1.5, 
                            pattern: 'rings',
                            glow: false
                        },
                        'min': { 
                            strokeWidth: 2, 
                            pattern: 'pulsar',
                            glow: true
                        },
                        'key': { 
                            strokeWidth: 2, 
                            pattern: 'corona',
                            glow: true
                        },
                        'pivot': { 
                            strokeWidth: 2.5, 
                            pattern: 'saturn',
                            glow: true
                        },
                        'merged': { 
                            strokeWidth: 1.5, 
                            pattern: 'neptune',
                            glow: false
                        }
                    };

                    // 데이터 확장: 균일한 궤도 배치로 변경
                    const polarData = dataset.map((d, i) => {
                        // 행성들을 궤도 레이어로 구성
                        const totalItems = dataset.length;
                        const layerCount = 5;  // 궤도 레이어 수
                        const itemsPerLayer = Math.ceil(totalItems / layerCount);
                        
                        // 어느 레이어에 배치할지 결정
                        const layerIndex = Math.floor(i / itemsPerLayer);
                        const posInLayer = i % itemsPerLayer;
                        
                        // 레이어별 반지름
                        const layerRadius = maxRadius * ((layerIndex + 1) / layerCount);
                        
                        // 레이어 내 위치에 따른 각도
                        const angleStep = (2 * Math.PI) / itemsPerLayer;
                        // 각 레이어는 시작 각도를 조금씩 다르게하여 균등 분포
                        const startAngle = (layerIndex * Math.PI / layerCount);
                        const angle = startAngle + (posInLayer * angleStep);
                        
                        // 좌표 변환
                        const x = center + layerRadius * Math.cos(angle);
                        const y = center + layerRadius * Math.sin(angle);
                        
                        // 크기 계산 (값에 비례, 상태에 따라 다름)
                        const baseSize = 16; // 기본 크기 약간 줄임
                        const valueSize = (d.value / dataset.length) * 20;
                          // 상태별 크기 배율 - 더욱 역동적으로 강화
                        const stateMultiplier = 
                            d.state === 'comparing' ? 1.5 : 
                            d.state === 'swapped' ? 1.4 : 
                            d.state === 'pivot' ? 1.7 : 
                            d.state === 'key' ? 1.45 :
                            d.state === 'min' ? 1.4 : 
                            d.state === 'sorted' ? 1.1 : 1.0;
                            
                        const size = (baseSize + valueSize) * stateMultiplier;
                        
                        // 행성 스타일 결정
                        const style = planetStyles[d.state] || planetStyles.default;
                        const colors = colorMap[d.state] || colorMap.default;
                        
                        return {
                            ...d,
                            x,
                            y,
                            size,
                            angle,
                            radius: layerRadius,
                            orbitIndex: layerIndex,
                            fill: colors.fill,
                            stroke: colors.stroke,
                            strokeWidth: style.strokeWidth,
                            pattern: style.pattern,
                            glow: style.glow,
                            opacity: d.state === 'default' ? 0.85 : 1.0
                        };
                    });
                      // 중앙 "태양" 데이터 (향상된 태양 효과)
                    const sunData = [{
                        x: center,
                        y: center,
                        size: 70, // 태양 크기 조정
                        color: algoInfo[algorithm].color,
                        glowColor: algoInfo[algorithm].color + "88", // 반투명 글로우 효과
                        isSun: true,
                        opacity: 0.9
                    }];
                    
                    // 개선된 궤도선 데이터 (각 레이어에 맞는 궤도) 
                    const orbitData = [];
                    const layerCount = 5; // 행성 레이어 수와 동일하게
                    
                    // 각 레이어마다 궤도 생성
                    for (let layer = 1; layer <= layerCount; layer++) {
                        const orbitRadius = maxRadius * (layer / layerCount);
                        
                        // 각 궤도는 조밀하게 점으로 표현
                        for (let angle = 0; angle < 360; angle += 3) {
                            const radian = (angle * Math.PI) / 180;
                            orbitData.push({
                                x: center + orbitRadius * Math.cos(radian),
                                y: center + orbitRadius * Math.sin(radian),
                                radius: orbitRadius,
                                layer: layer,
                                opacity: 0.12 - (layer / layerCount) * 0.04 // 바깥 궤도일수록 더 투명하게
                            });
                        }
                    }
                      // Vega 스펙 정의 (완전히 개선됨)
                    return {
                        "$schema": "https://vega.github.io/schema/vega/v5.json",
                        "width": containerWidth,
                        "height": containerHeight,
                        "padding": 0,
                        "autosize": {"type": "fit", "contains": "padding"},
                        "background": null,                        
                        "data": [
                            {
                                "name": "orbits",
                                "values": orbitData
                            },
                            {
                                "name": "planets",
                                "values": polarData
                            },
                            {
                                "name": "sun",
                                "values": sunData
                            }
                        ],
                        
                        "marks": [
                            {
                                "type": "symbol",
                                "from": {"data": "orbits"},
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "size": {"value": 0.8},
                                        "fill": {"value": "rgba(255,255,255,0.15)"},
                                        "fillOpacity": {"field": "opacity"}
                                    }
                                }
                            },
                            {
                                "type": "symbol",
                                "from": {"data": "sun"},
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "size": {"field": "size", "mult": 12}
                                    },
                                    "update": {
                                        "fill": {"field": "color"},
                                        "fillOpacity": {"field": "opacity"},
                                        "stroke": {"value": "rgba(255,255,255,0.8)"},
                                        "strokeOpacity": {"value": 0.6},
                                        "strokeWidth": {"value": 3}
                                    }
                                }
                            },
                            {
                                "type": "symbol", 
                                "from": {"data": "sun"},
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "size": {"field": "size", "mult": 20}
                                    },
                                    "update": {
                                        "fill": {"field": "color"},
                                        "fillOpacity": {"value": 0.3},
                                        "stroke": {"value": "none"}
                                    }
                                }
                            },                            {
                                "type": "symbol",
                                "from": {"data": "planets"},
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "size": {"field": "size", "mult": 10}
                                    },
                                    "update": {
                                        "fill": {"field": "fill"},
                                        "fillOpacity": {"field": "opacity"},
                                        "stroke": {"field": "stroke"},
                                        "strokeOpacity": {
                                            "signal": "datum.state === 'comparing' || datum.state === 'swapped' || datum.state === 'pivot' ? 1.0 : 0.9"
                                        },
                                        "strokeWidth": {
                                            "signal": "datum.state === 'comparing' ? 3 : datum.state === 'pivot' ? 4 : datum.strokeWidth"
                                        }
                                    }
                                }
                            },
                            {
                                "type": "symbol",
                                "from": {"data": "planets"},
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "size": {"field": "size", "mult": 16}
                                    },
                                    "update": {
                                        "fill": {"field": "fill"},
                                        "fillOpacity": {
                                            "signal": "datum.glow ? 0.3 : 0.2"
                                        },
                                        "stroke": {"value": "none"}
                                    }
                                }
                            },
                            {
                                "type": "symbol",
                                "from": {"data": "planets"},
                                "transform": [
                                    {
                                        "type": "filter",
                                        "expr": "datum.state === 'comparing' || datum.state === 'swapped' || datum.state === 'pivot'"
                                    }
                                ],
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "size": {"field": "size", "mult": 25}
                                    },
                                    "update": {
                                        "fill": {"field": "fill"},
                                        "fillOpacity": {"value": 0.15},
                                        "stroke": {"value": "none"}
                                    }
                                }
                            },
                            {
                                "type": "text",
                                "from": {"data": "planets"},
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "text": {"field": "value"},
                                        "align": {"value": "center"},
                                        "baseline": {"value": "middle"},
                                        "fontSize": {"value": 13},
                                        "fontWeight": {"value": "bold"},
                                        "font": {"value": "Noto Sans KR"}
                                    },
                                    "update": {
                                        "fill": {"value": "white"},
                                        "fillOpacity": {"value": 1.0},
                                        "stroke": {"value": "rgba(0,0,0,0.5)"},
                                        "strokeWidth": {"value": 0.5}
                                    }
                                }
                            }
                        ]
                    };
                }, [algorithm]);
                  // Vega 시각화 렌더링 (애니메이션 개선)
                useEffect(() => {
                    if (!data || data.length === 0 || !containerRef.current) return;
                    
                    const vegaSpec = createVegaSpec(data);
                    
                    // 기존 배열 컨테이너 제거
                    const existingArray = containerRef.current.querySelector('.array-container');
                    if (existingArray) {
                        existingArray.remove();
                    }
                    
                    // Vega 시각화 렌더링 (부드러운 애니메이션을 위한 설정)
                    vegaEmbed('#vega-vis', vegaSpec, {
                        actions: false,
                        renderer: 'canvas',
                        tooltip: false,
                        patch: (spec) => {
                            // 애니메이션 지연시간 설정
                            if (spec.marks) {
                                spec.marks.forEach(mark => {
                                    if (mark.type === 'symbol' && mark.from && mark.from.data === 'planets') {
                                        mark.encode.update = {
                                            ...mark.encode.update,
                                            // 부드러운 트랜지션 효과
                                            x: { field: 'x', transition: { duration: 300, ease: 'cubic-in-out' } },
                                            y: { field: 'y', transition: { duration: 300, ease: 'cubic-in-out' } },
                                            size: { field: 'size', mult: mark.encode.enter.size.mult, transition: { duration: 200, ease: 'quad-out' } },
                                            fill: { field: 'fill', transition: { duration: 150, ease: 'linear' } },
                                            fillOpacity: { field: 'opacity', transition: { duration: 150, ease: 'linear' } }
                                        };
                                    }
                                });
                            }
                            return spec;
                        }
                    }).then(result => {
                        vegaRef.current = result;
                        
                        // 특수 효과: 정렬 완료시 반짝임 효과
                        const allSorted = data.every(d => d.state === 'sorted');
                        if (allSorted && vegaRef.current) {
                            setTimeout(() => {
                                const view = vegaRef.current.view;
                                // 완료 효과를 위한 임시 글로우 추가
                                view.signal('completionGlow', true);
                                view.runAsync();
                                setTimeout(() => {
                                    view.signal('completionGlow', false);
                                    view.runAsync();
                                }, 1000);
                            }, 500);
                        }
                    }).catch(console.error);
                    
                    // 배열 시각화 (애니메이션 강화)
                    const containerEl = containerRef.current;
                    const arrayContainer = document.createElement("div");
                    arrayContainer.className = "array-container";
                    
                    arrayContainer.innerHTML = '';
                    data.forEach((item, index) => {
                        const arrayItem = document.createElement("div");
                        arrayItem.className = `array-item ${item.state || 'default'}`;
                        arrayItem.textContent = item.value;
                        
                        // 강화된 상태별 애니메이션 효과
                        if (item.state === 'comparing') {
                            arrayItem.style.animation = 'pulse 0.8s infinite alternate';
                        } else if (item.state === 'swapped') {
                            arrayItem.style.animation = 'bounce 0.6s ease-out';
                        } else if (item.state === 'pivot') {
                            arrayItem.style.animation = 'glow 1.5s infinite alternate';
                        } else if (item.state === 'sorted') {
                            arrayItem.style.animation = 'fadeInScale 0.5s ease-out';
                        }
                        
                        // 순차적 등장 효과 (처음 로드시)
                        if (data.every(d => d.state === 'default')) {
                            arrayItem.style.animationDelay = `${index * 50}ms`;
                        }
                        
                        arrayContainer.appendChild(arrayItem);
                    });
                    
                    containerEl.appendChild(arrayContainer);
                }, [data, createVegaSpec]);return (
                    <div ref={containerRef} className="vis-container">
                        <div id="vega-vis"></div>
                    </div>
                );
            };
              // 정보 카드 컴포넌트 (애니메이션 상태 정보 강화)
            const InfoCard = ({ algo, time, isSorting }) => {
                const INFO_CONTENT = {
                    bubble: { 
                        title: '중력파 정렬 (버블)', 
                        concept: '이웃한 두 행성을 비교하여 질량(값)이 잘못되었을 경우 서로의 궤도를 바꿉니다. 이 과정이 반복되며 가장 무거운 행성이 바깥 궤도로 밀려납니다.', 
                        bigO: 'O(n²)', 
                        features: '구현이 가장 단순하지만, 데이터가 많아질수록 비효율적입니다.',
                        animation: '이웃 행성들이 비교되며 점차 가장 무거운 행성이 바깥 궤도로 이동합니다.'
                    },
                    selection: { 
                        title: '항성 형성 (선택)', 
                        concept: '성운 전체에서 가장 무거운 행성을 찾아 가장 바깥 궤도에 고정시킵니다. 이 과정을 반복하며 안쪽으로 궤도를 채워나갑니다.', 
                        bigO: 'O(n²)', 
                        features: '데이터 이동이 적지만, 버블 정렬처럼 비효율적입니다.',
                        animation: '최솟값 행성이 발광하며 찾아진 후 올바른 궤도로 이동합니다.'
                    },
                    insertion: { 
                        title: '궤도 동기화 (삽입)', 
                        concept: '하나의 행성을 선택해, 이미 정렬된 안쪽 궤도의 행성들과 비교하며 자신의 올바른 궤도를 찾아 삽입됩니다.', 
                        bigO: 'O(n²) / 최선: O(n)', 
                        features: '데이터가 거의 정렬된 상태에서 매우 효율적으로 작동합니다.',
                        animation: '키 행성이 이미 정렬된 궤도들과 비교하며 적절한 위치를 찾습니다.'
                    },
                    merge: { 
                        title: '성운 병합 (합병)', 
                        concept: '성운을 계속 절반으로 나누어 최소 단위(행성 하나)로 분해한 뒤, 다시 두 성운씩 질량 순서에 맞게 병합하며 전체를 정렬합니다.', 
                        bigO: 'O(n log n)', 
                        features: '안정적이고 항상 일정한 성능을 보장하는 강력한 정렬 방식입니다.',
                        animation: '행성들이 분할되고 병합되며 질서정연하게 정렬됩니다.'
                    },
                    quick: { 
                        title: '퀘이사 피벗 (퀵)', 
                        concept: '성운에서 임의의 기준 행성(피벗)을 선택하고, 그보다 가벼운 행성들은 안쪽, 무거운 행성들은 바깥쪽으로 재배치합니다. 이 과정을 분할된 각 영역에서 반복합니다.', 
                        bigO: 'O(n log n) / 최악: O(n²)', 
                        features: '평균적으로 매우 빠르지만, 기준 행성 선택에 따라 성능이 크게 달라질 수 있습니다.',
                        animation: '피벗 행성이 강력하게 발광하며 다른 행성들이 양쪽으로 분할됩니다.'
                    }
                };
                
                const content = INFO_CONTENT[algo];
                return (
                    <div className="info-card-wrapper">
                        <h2 className="info-title">
                            {content.title}
                            {isSorting && (
                                <span style={{fontSize: '0.8rem', color: 'var(--accent-yellow)', display: 'flex', alignItems: 'center', gap: '0.3rem'}}>
                                    <div style={{
                                        width: '6px', 
                                        height: '6px', 
                                        borderRadius: '50%', 
                                        backgroundColor: 'var(--accent-yellow)',
                                        animation: 'pulse 1s infinite'
                                    }}></div>
                                    조율 중
                                </span>
                            )}
                        </h2>
                        <div className="info-timer">
                            <span>⏱️ </span>
                            <span className="timer-value">{time.toFixed(2)} 초</span>
                        </div>
                        <div>
                            <h3 className="info-heading">핵심 원리</h3>
                            <p className="info-text">{content.concept}</p>
                            <h3 className="info-heading">시간 복잡도</h3>
                            <p className="info-text" style={{fontFamily: 'monospace'}}>{content.bigO}</p>
                            <h3 className="info-heading">애니메이션 효과</h3>
                            <p className="info-text">{content.animation}</p>
                            <h3 className="info-heading">특징</h3>
                            <p className="info-text">{content.features}</p>
                        </div>
                    </div>
                );
            };
            
            // 메인 앱 컴포넌트
            function App() {
                const [data, setData] = useState([]);
                const [algorithm, setAlgorithm] = useState('bubble');
                const [isSorting, setIsSorting] = useState(false);
                const [time, setTime] = useState(0);
                const [speed, setSpeed] = useState(75);
                
                const animationRef = useRef(null);
                const timerRef = useRef(null);
                const generatorRef = useRef(null);
                const startTimeRef = useRef(null);

                // 초기 데이터 생성
                const generateNewData = useCallback(() => {
                    const newData = Array.from({ length: N }, (_, i) => ({
                        value: i + 1,
                        id: i,
                        state: 'default'
                    }));
                    for (let i = newData.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [newData[i], newData[j]] = [newData[j], newData[i]];
                    }
                    return newData;
                }, []);

                useEffect(() => {
                    setData(generateNewData());
                    return () => {
                        if (animationRef.current) clearTimeout(animationRef.current);
                        if (timerRef.current) clearInterval(timerRef.current);
                    };
                }, [generateNewData]);

                const clearAnimationFrame = () => {
                    if (animationRef.current) {
                        clearTimeout(animationRef.current);
                        animationRef.current = null;
                    }
                    if (timerRef.current) {
                        clearInterval(timerRef.current);
                        timerRef.current = null;
                    }
                };
                
                const stopSorting = () => {
                    clearAnimationFrame();
                    setIsSorting(false);
                    generatorRef.current = null;
                };
                
                const handleReset = () => {
                    if (isSorting) stopSorting();
                    setTime(0);
                    setData(generateNewData());
                };
                  const handleStartStop = () => {
                    if (isSorting) {
                        stopSorting();
                    } else {
                        startSorting();
                    }
                };
                
                const startSorting = () => {
                    clearAnimationFrame();
                    setIsSorting(true);
                    
                    // 시작 효과: 모든 행성을 기본 상태로 초기화
                    const initialData = data.map(d => ({ ...d, state: 'default' }));
                    setData(initialData);
                    
                    try {
                        generatorRef.current = sortGenerators[algorithm]([...data]);
                        startTimeRef.current = performance.now();
                        
                        timerRef.current = setInterval(() => {
                            setTime((performance.now() - startTimeRef.current) / 1000);
                        }, 10);
                        
                        // 시작 지연 효과 (행성들이 준비되는 시간)
                        setTimeout(() => {
                            const animate = () => {
                                try {
                                    const result = generatorRef.current.next();
                                    
                                    if (!result.done) {
                                        setData(result.value);
                                        
                                        // 적응형 속도: 비교/교환 상태일 때 조금 더 느리게
                                        const hasActiveStates = result.value.some(d => 
                                            d.state === 'comparing' || d.state === 'swapped' || d.state === 'pivot'
                                        );
                                        const adaptiveSpeed = hasActiveStates ? speed * 1.3 : speed;
                                        
                                        animationRef.current = setTimeout(animate, adaptiveSpeed);
                                    } else {
                                        // 완료 효과: 순차적으로 정렬됨 상태로 변경
                                        const finalData = result.value;
                                        let completionIndex = 0;
                                        
                                        const completeAnimation = () => {
                                            if (completionIndex < finalData.length) {
                                                const updatedData = finalData.map((d, i) => ({
                                                    ...d,
                                                    state: i <= completionIndex ? 'sorted' : d.state
                                                }));
                                                setData(updatedData);
                                                completionIndex++;
                                                setTimeout(completeAnimation, 100);
                                            } else {
                                                clearAnimationFrame();
                                                setIsSorting(false);
                                            }
                                        };
                                        
                                        setTimeout(completeAnimation, 300);
                                    }
                                } catch (error) {
                                    console.error('애니메이션 오류:', error);
                                    clearAnimationFrame();
                                    setIsSorting(false);
                                }
                            };
                            
                            animate();
                        }, 500); // 시작 지연
                        
                    } catch (error) {
                        console.error('정렬 시작 오류:', error);
                        clearAnimationFrame();
                        setIsSorting(false);
                    }
                };
                
                const handleAlgorithmChange = (algo) => {
                    if (algo === algorithm) return;
                    if (isSorting) stopSorting();
                    setAlgorithm(algo);
                    setTime(0);
                    setData(generateNewData());
                };
                
                const formatSpeed = (speedValue) => {
                    if (speedValue >= 100) return "느림";
                    if (speedValue >= 50) return "보통";
                    return "빠름";
                };                return (
                    <div className="app-wrapper">
                        <div className="header">
                            <h1 className="title">알고리즘 성운 (Algorithm Nebula)</h1>
                            <p className="subtitle">Vega로 구현한 우주 정렬 알고리즘 시각화</p>
                        </div>
                        
                        <div className="controls-group">
                            <div className="control-section">
                                {Object.keys(algoInfo).map(key => (
                                    <button 
                                        key={key}
                                        className={`algo-button ${algorithm === key ? 'active' : ''}`}
                                        onClick={() => handleAlgorithmChange(key)}
                                    >
                                        {key === 'bubble' ? '중력파 정렬' : 
                                         key === 'selection' ? '항성 형성' :
                                         key === 'insertion' ? '궤도 동기화' :
                                         key === 'merge' ? '성운 병합' : '퀘이사 피벗'}
                                    </button>
                                ))}
                            </div>
                            
                            <div className="control-section">
                                <div className="slider-container">
                                    <span>속도:</span>
                                    <input 
                                        type="range"
                                        min="1"
                                        max="100" 
                                        value={speed}
                                        className="slider"
                                        onChange={e => setSpeed(parseInt(e.target.value))}
                                        disabled={isSorting}
                                    />
                                    <span className="slider-value">{formatSpeed(speed)}</span>
                                </div>
                            </div>
                        </div>                        <div className="main-layout">
                            <VegaVisualization data={data} algorithm={algorithm} />
                            <InfoCard algo={algorithm} time={time} isSorting={isSorting} />
                        </div>

                        <div className="actions">
                            <button 
                                className={`button ${isSorting ? 'primary-button running' : 'primary-button'}`}
                                onClick={handleStartStop}
                            >
                                {isSorting ? '중지' : '시작'}
                            </button>
                            <button 
                                className="button secondary-button" 
                                onClick={handleReset}
                                disabled={isSorting}
                            >
                                초기화
                            </button>
                        </div>
                    </div>
                );
            }

            const container = document.getElementById('root');
            const root = ReactDOM.createRoot(container);
            root.render(<App />);
        }
        
        // 라이브러리 로드 확인
        let attempts = 0;
        const maxAttempts = 50;
        
        const readyCheck = setInterval(() => {
            attempts++;
            if (window.React && window.ReactDOM && window.ReactDOM.createRoot && window.vega) {
                clearInterval(readyCheck);
                runApp();
            } else if (attempts >= maxAttempts) {
                clearInterval(readyCheck);
                document.getElementById('root').innerHTML = `
                    <div class="alert alert-danger">
                        <h2>라이브러리 로드 중 오류가 발생했습니다</h2>
                        <p>페이지를 새로고침하거나 다른 브라우저에서 시도해 주세요.</p>
                    </div>
                `;
            }
        }, 100);    </script>
</body>
</html>
