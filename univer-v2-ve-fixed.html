<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>성운의 조율 - Vega 버전 (개선됨)</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- React, Babel 로드 -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Vega 및 Vega-Embed 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/vega@5.22.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@5.6.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.21.0"></script>
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <style>
        body {
            background-color: #0a1629;
            min-height: 100vh;
            background-image: radial-gradient(circle at 10% 20%, rgba(60, 108, 223, 0.1) 0%, transparent 20%),
                              radial-gradient(circle at 90% 80%, rgba(138, 79, 255, 0.1) 0%, transparent 25%);
            color: #F0F6FF;
        }
        
        .app-card {
            background-color: #091c3e !important;
            border: 1px solid rgba(60, 108, 223, 0.3) !important;
        }
        
        .card-header-gradient {
            height: 5px;
            background: linear-gradient(90deg, #3C6CDF, #8A4FFF, #F5597F, #57CBFF);
            border-radius: 5px 5px 0 0;
        }
        
        .vis-container {
            background-color: #050e20;
            min-height: 60vh;
            border-radius: 0.5rem;
            box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.4);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .title-gradient {
            background: linear-gradient(90deg, #FFFFFF, #8A9EDF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* 알고리즘 버튼 스타일 */
        .algo-btn {
            position: relative;
            overflow: visible;
        }
        
        .complexity-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 0.7rem;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .algo-btn:hover .complexity-badge,
        .algo-btn.active .complexity-badge {
            opacity: 1;
            transform: scale(1);
        }
        
        /* 배열 시각화 */
        .array-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            max-width: 90%;
            overflow-x: auto;
        }
        
        .array-item {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            font-family: monospace;
            transition: all 0.3s ease;
        }
        
        .array-item.default { background-color: rgba(60, 108, 223, 0.6); }
        .array-item.comparing { 
            background-color: rgba(245, 89, 127, 0.9);
            transform: translateY(-4px);
            box-shadow: 0 4px 8px rgba(245, 89, 127, 0.3);
        }
        .array-item.swapped { 
            background-color: rgba(252, 187, 74, 0.9);
            transform: translateY(-2px) scale(1.1);
            box-shadow: 0 4px 8px rgba(252, 187, 74, 0.3);
        }
        .array-item.pivot { 
            background-color: rgba(138, 79, 255, 0.9);
            box-shadow: 0 4px 8px rgba(138, 79, 255, 0.3);
        }
        .array-item.sorted { 
            background-color: rgba(87, 203, 255, 0.9);
            box-shadow: 0 4px 8px rgba(87, 203, 255, 0.3);
        }
        .array-item.min { 
            background-color: rgba(131, 247, 169, 0.9);
            box-shadow: 0 4px 8px rgba(131, 247, 169, 0.3);
        }
        .array-item.key { 
            background-color: rgba(252, 187, 74, 0.9);
            box-shadow: 0 4px 8px rgba(252, 187, 74, 0.3);
        }
        .array-item.merged { 
            background-color: rgba(87, 203, 255, 0.9);
            animation: fadeIn 0.5s;
            box-shadow: 0 4px 8px rgba(87, 203, 255, 0.3);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        #vega-vis {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="py-4 text-light">
    <div id="root" class="container"></div>

    <script type="text/babel">
        function runApp() {
            const { useState, useEffect, useRef, useCallback } = React;
            const N = 25; // 데이터 포인트 수
            
            // 알고리즘 정보
            const algoInfo = {
                bubble: { 
                    title: '버블 정렬 (Bubble Sort)', 
                    concept: '이웃한 두 요소를 비교하여 순서가 잘못되었을 경우 서로의 위치를 바꿉니다.',
                    color: '#3C6CDF',
                    complexity: 'O(n²)',
                    bgClass: 'primary'
                },
                selection: { 
                    title: '선택 정렬 (Selection Sort)', 
                    concept: '전체 배열에서 최솟값(또는 최댓값)을 찾아 적절한 위치로 이동시킵니다.',
                    color: '#8A4FFF',
                    complexity: 'O(n²)',
                    bgClass: 'purple'
                },
                insertion: { 
                    title: '삽입 정렬 (Insertion Sort)', 
                    concept: '각 요소를 올바른 위치에 삽입하여 부분적으로 정렬된 배열을 점진적으로 구축합니다.',
                    color: '#F5597F',
                    complexity: 'O(n²)',
                    bgClass: 'danger'
                },
                merge: { 
                    title: '병합 정렬 (Merge Sort)', 
                    concept: '배열을 작은 부분으로 나누고, 각 부분을 정렬한 후 병합하는 분할 정복 방식입니다.',
                    color: '#57CBFF',
                    complexity: 'O(n log n)',
                    bgClass: 'info'
                },
                quick: { 
                    title: '퀵 정렬 (Quick Sort)', 
                    concept: '피벗 요소를 기준으로 배열을 분할하고 각 부분을 재귀적으로 정렬합니다.',
                    color: '#FCBB4A',
                    complexity: 'O(n log n)*',
                    bgClass: 'warning'
                }
            };

            // 버블 정렬
            function* bubbleSort(arr) { 
                let a = JSON.parse(JSON.stringify(arr)); 
                for(let i = 0; i < a.length; i++) { 
                    for (let j = 0; j < a.length - i - 1; j++) { 
                        a.forEach(d => { if(d.state !== 'sorted') d.state = 'default'; });
                        a[j].state = 'comparing'; 
                        a[j+1].state = 'comparing';
                        yield [...a];
                        
                        if (a[j].value > a[j+1].value) {
                            const temp = {...a[j]};
                            a[j] = {...a[j+1]};
                            a[j+1] = temp;
                            a[j].state = 'swapped';
                            a[j+1].state = 'swapped';
                            yield [...a];
                        }
                    }
                    a[a.length - i - 1].state = 'sorted';
                }
                a.forEach(d => d.state = 'sorted');
                return [...a];
            }
            
            // 선택 정렬
            function* selectionSort(arr) { 
                let a = JSON.parse(JSON.stringify(arr)); 
                for(let i = 0; i < a.length - 1; i++) { 
                    let min_idx = i; 
                    a.forEach((d, k) => d.state = k < i ? 'sorted' : 'default');
                    a[min_idx].state = 'min';
                    yield [...a];
                    
                    for(let j = i + 1; j < a.length; j++) {
                        a[j].state = 'comparing';
                        yield [...a];
                        
                        if (a[j].value < a[min_idx].value) {
                            a[min_idx].state = 'default';
                            min_idx = j;
                            a[min_idx].state = 'min';
                            yield [...a];
                        } else {
                            a[j].state = 'default';
                        }
                    }
                    
                    if (min_idx !== i) {
                        const temp = {...a[i]};
                        a[i] = {...a[min_idx]};
                        a[min_idx] = temp;
                        a[i].state = 'sorted';
                        yield [...a];
                    }
                    a[i].state = 'sorted';
                }
                a[a.length - 1].state = 'sorted';
                return [...a];
            }
            
            // 삽입 정렬
            function* insertionSort(arr) {
                let a = JSON.parse(JSON.stringify(arr));
                for (let i = 1; i < a.length; i++) {
                    a.forEach((d, k) => d.state = k < i ? 'sorted' : 'default');
                    a[i].state = 'key';
                    yield [...a];
                    
                    let key = {...a[i]};
                    let j = i - 1;
                    
                    while (j >= 0 && a[j].value > key.value) {
                        a[j].state = 'comparing';
                        a[j + 1].state = 'comparing';
                        yield [...a];
                        
                        a[j + 1] = {...a[j]};
                        a[j + 1].state = 'swapped';
                        yield [...a];
                        j--;
                    }
                    a[j + 1] = key;
                    a[j + 1].state = 'sorted';
                    yield [...a];
                }
                a.forEach(d => d.state = 'sorted');
                return [...a];
            }
            
            // 병합 정렬
            function* mergeSort(arr) {
                let a = JSON.parse(JSON.stringify(arr));
                yield* mergeSortHelper(a, 0, a.length - 1);
                a.forEach(d => d.state = 'sorted');
                return [...a];
            }
            
            function* mergeSortHelper(arr, left, right) {
                if (left >= right) return;
                
                const mid = Math.floor((left + right) / 2);
                yield* mergeSortHelper(arr, left, mid);
                yield* mergeSortHelper(arr, mid + 1, right);
                yield* merge(arr, left, mid, right);
            }
            
            function* merge(arr, left, mid, right) {
                const leftArr = arr.slice(left, mid + 1);
                const rightArr = arr.slice(mid + 1, right + 1);
                
                let i = 0, j = 0, k = left;
                
                while (i < leftArr.length && j < rightArr.length) {
                    arr.forEach(d => d.state = 'default');
                    arr[k].state = 'comparing';
                    yield [...arr];
                    
                    if (leftArr[i].value <= rightArr[j].value) {
                        arr[k] = {...leftArr[i]};
                        i++;
                    } else {
                        arr[k] = {...rightArr[j]};
                        j++;
                    }
                    arr[k].state = 'merged';
                    k++;
                    yield [...arr];
                }
                
                while (i < leftArr.length) {
                    arr[k] = {...leftArr[i]};
                    arr[k].state = 'merged';
                    i++;
                    k++;
                    yield [...arr];
                }
                
                while (j < rightArr.length) {
                    arr[k] = {...rightArr[j]};
                    arr[k].state = 'merged';
                    j++;
                    k++;
                    yield [...arr];
                }
            }
            
            // 퀵 정렬
            function* quickSort(arr) {
                let a = JSON.parse(JSON.stringify(arr));
                yield* quickSortHelper(a, 0, a.length - 1);
                a.forEach(d => d.state = 'sorted');
                return [...a];
            }
            
            function* quickSortHelper(arr, low, high) {
                if (low < high) {
                    const pivotIndex = yield* partition(arr, low, high);
                    yield* quickSortHelper(arr, low, pivotIndex - 1);
                    yield* quickSortHelper(arr, pivotIndex + 1, high);
                }
            }
            
            function* partition(arr, low, high) {
                arr.forEach(d => d.state = 'default');
                const pivot = arr[high];
                pivot.state = 'pivot';
                yield [...arr];
                
                let i = low - 1;
                
                for (let j = low; j < high; j++) {
                    arr[j].state = 'comparing';
                    yield [...arr];
                    
                    if (arr[j].value < pivot.value) {
                        i++;
                        if (i !== j) {
                            [arr[i], arr[j]] = [arr[j], arr[i]];
                            arr[i].state = 'swapped';
                            arr[j].state = 'swapped';
                            yield [...arr];
                        }
                    }
                    arr[j].state = 'default';
                }
                
                [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                arr[i + 1].state = 'pivot';
                yield [...arr];
                
                return i + 1;
            }
            
            const sortGenerators = { 
                bubble: bubbleSort, 
                selection: selectionSort,
                insertion: insertionSort,
                merge: mergeSort,
                quick: quickSort
            };

            // Vega 시각화 컴포넌트
            const VegaVisualization = ({ data, algorithm }) => {
                const containerRef = useRef();
                const vegaRef = useRef(null);
                
                // Vega 스펙 생성 함수
                const createVegaSpec = useCallback((dataset) => {
                    // 중심점 좌표
                    const center = 200;
                    // 상태에 따른 색상 매핑
                    const colorMap = {
                        'default': '#3C6CDF',
                        'comparing': '#F56565',
                        'swapped': '#ED8936',
                        'sorted': '#57CBFF',
                        'min': '#68D391',
                        'key': '#ECC94B',
                        'pivot': '#8A4FFF',
                        'merged': '#57CBFF'
                    };
                    
                    // 데이터 확장: 극좌표 계산 (황금각으로 균등 분포)
                    const polarData = dataset.map((d, i) => {
                        // 황금각(Golden Angle) 사용으로 균등 분포 구현
                        const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // 약 137.5도
                        const angle = i * goldenAngle;
                        
                        // 아르키메데스 나선 공식 개선
                        const spiralTightness = 8; // 나선의 간격
                        const radius = Math.min(150, spiralTightness * Math.sqrt(i + 1));
                        
                        // 극좌표 -> 데카르트 좌표 변환
                        const x = center + radius * Math.cos(angle);
                        const y = center + radius * Math.sin(angle);
                        
                        // 크기 계산 (더 큰 노드)
                        const baseSize = 20; // 기본 크기 증가
                        const variableSize = (d.value / dataset.length) * 25; // 가변 크기 증가
                        const size = baseSize + variableSize;
                        
                        return {
                            ...d,
                            x,
                            y,
                            size,
                            angle,
                            radius,
                            color: colorMap[d.state] || colorMap.default
                        };
                    });
                    
                    // 중앙 "태양" 데이터 (크기 확대)
                    const sunData = [{
                        x: center,
                        y: center,
                        size: 60, // 중앙 태양 크기 증가
                        color: algoInfo[algorithm].color,
                        isSun: true
                    }];
                    
                    // Vega 스펙 정의
                    return {
                        "$schema": "https://vega.github.io/schema/vega/v5.json",
                        "width": 400,
                        "height": 400,
                        "padding": 20,
                        "autosize": "none",
                        "background": null,
                        
                        "data": [
                            {
                                "name": "planets",
                                "values": polarData
                            },
                            {
                                "name": "sun",
                                "values": sunData
                            }
                        ],
                        
                        "marks": [
                            {
                                "type": "symbol",
                                "from": {"data": "sun"},
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "size": {"field": "size", "mult": 10},
                                        "fill": {"field": "color"}
                                    },
                                    "update": {
                                        "fillOpacity": {"value": 1},
                                        "stroke": {"value": "white"},
                                        "strokeOpacity": {"value": 0.3},
                                        "strokeWidth": {"value": 2}
                                    }
                                }
                            },
                            {
                                "type": "symbol",
                                "from": {"data": "planets"},
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "size": {"field": "size", "mult": 12}
                                    },
                                    "update": {
                                        "fill": {"field": "color"},
                                        "fillOpacity": {"value": 0.9},
                                        "stroke": {"value": "white"},
                                        "strokeOpacity": {"value": 0.4},
                                        "strokeWidth": {"value": 1.5}
                                    }
                                }
                            },
                            {
                                "type": "text",
                                "from": {"data": "planets"},
                                "encode": {
                                    "enter": {
                                        "x": {"field": "x"},
                                        "y": {"field": "y"},
                                        "text": {"field": "value"},
                                        "align": {"value": "center"},
                                        "baseline": {"value": "middle"},
                                        "fill": {"value": "white"},
                                        "fontSize": {"value": 14}, // 텍스트 크기 증가
                                        "fontWeight": {"value": "bold"},
                                        "font": {"value": "monospace"}
                                    }
                                }
                            }
                        ]
                    };
                }, [algorithm]);
                
                // Vega 시각화 렌더링
                useEffect(() => {
                    if (!data || data.length === 0 || !containerRef.current) return;
                    
                    const vegaSpec = createVegaSpec(data);
                    
                    // 기존 배열 컨테이너 제거
                    const existingArray = containerRef.current.querySelector('.array-container');
                    if (existingArray) {
                        existingArray.remove();
                    }
                    
                    // Vega 시각화 렌더링
                    vegaEmbed('#vega-vis', vegaSpec, {
                        actions: false,
                        renderer: 'canvas'
                    }).then(result => {
                        vegaRef.current = result;
                    }).catch(console.error);
                    
                    // 배열 시각화
                    const containerEl = containerRef.current;
                    const arrayContainer = document.createElement("div");
                    arrayContainer.className = "array-container";
                    
                    arrayContainer.innerHTML = '';
                    data.forEach(item => {
                        const arrayItem = document.createElement("div");
                        arrayItem.className = `array-item ${item.state || 'default'}`;
                        arrayItem.textContent = item.value;
                        arrayContainer.appendChild(arrayItem);
                    });
                    
                    containerEl.appendChild(arrayContainer);
                }, [data, createVegaSpec]);

                return (
                    <div ref={containerRef} className="vis-container">
                        <div id="vega-vis"></div>
                    </div>
                );
            };
            
            // 메인 앱 컴포넌트
            function App() {
                const [data, setData] = useState([]);
                const [algorithm, setAlgorithm] = useState('bubble');
                const [isSorting, setIsSorting] = useState(false);
                const [time, setTime] = useState(0);
                const [speed, setSpeed] = useState(75);
                
                const animationRef = useRef(null);
                const timerRef = useRef(null);
                const generatorRef = useRef(null);
                const startTimeRef = useRef(null);

                // 초기 데이터 생성
                const generateNewData = useCallback(() => {
                    const newData = Array.from({ length: N }, (_, i) => ({
                        value: i + 1,
                        id: i,
                        state: 'default'
                    }));
                    for (let i = newData.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [newData[i], newData[j]] = [newData[j], newData[i]];
                    }
                    return newData;
                }, []);

                useEffect(() => {
                    setData(generateNewData());
                    return () => {
                        if (animationRef.current) clearTimeout(animationRef.current);
                        if (timerRef.current) clearInterval(timerRef.current);
                    };
                }, [generateNewData]);

                const clearAnimationFrame = () => {
                    if (animationRef.current) {
                        clearTimeout(animationRef.current);
                        animationRef.current = null;
                    }
                    if (timerRef.current) {
                        clearInterval(timerRef.current);
                        timerRef.current = null;
                    }
                };
                
                const stopSorting = () => {
                    clearAnimationFrame();
                    setIsSorting(false);
                    generatorRef.current = null;
                };
                
                const handleReset = () => {
                    if (isSorting) stopSorting();
                    setTime(0);
                    setData(generateNewData());
                };
                
                const handleStartStop = () => {
                    if (isSorting) {
                        stopSorting();
                    } else {
                        startSorting();
                    }
                };
                
                const startSorting = () => {
                    clearAnimationFrame();
                    setIsSorting(true);
                    
                    try {
                        generatorRef.current = sortGenerators[algorithm]([...data]);
                        startTimeRef.current = performance.now();
                        
                        timerRef.current = setInterval(() => {
                            setTime((performance.now() - startTimeRef.current) / 1000);
                        }, 10);
                        
                        const animate = () => {
                            try {
                                const result = generatorRef.current.next();
                                
                                if (!result.done) {
                                    setData(result.value);
                                    animationRef.current = setTimeout(animate, speed);
                                } else {
                                    setData(result.value);
                                    clearAnimationFrame();
                                    setIsSorting(false);
                                }
                            } catch (error) {
                                console.error('애니메이션 오류:', error);
                                clearAnimationFrame();
                                setIsSorting(false);
                            }
                        };
                        
                        animate();
                    } catch (error) {
                        console.error('정렬 시작 오류:', error);
                        clearAnimationFrame();
                        setIsSorting(false);
                    }
                };
                
                const handleAlgorithmChange = (algo) => {
                    if (algo === algorithm) return;
                    if (isSorting) stopSorting();
                    setAlgorithm(algo);
                    setTime(0);
                    setData(generateNewData());
                };
                
                const formatSpeed = (speedValue) => {
                    if (speedValue >= 100) return "느림";
                    if (speedValue >= 50) return "보통";
                    return "빠름";
                };

                return (
                    <div className="card app-card shadow-lg mt-4">
                        <div className="card-header-gradient"></div>
                        <div className="card-body">
                            <h1 className="display-5 text-center mb-3 title-gradient fw-bold">성운의 조율</h1>
                            <p className="text-center text-secondary mb-4">Vega로 구현한 정렬 알고리즘 시각화 (개선됨)</p>
                            
                            <div className="bg-dark bg-opacity-50 p-3 rounded mb-4">
                                <div className="d-flex flex-wrap justify-content-center gap-2">
                                    {Object.keys(algoInfo).map(key => (
                                        <button 
                                            key={key}
                                            className={`btn btn-${algorithm === key ? algoInfo[key].bgClass : 'outline-secondary'} algo-btn`}
                                            onClick={() => handleAlgorithmChange(key)}
                                        >
                                            {key === 'bubble' ? '버블' : 
                                             key === 'selection' ? '선택' :
                                             key === 'insertion' ? '삽입' :
                                             key === 'merge' ? '병합' : '퀵'}
                                            <span className={`position-absolute top-0 start-100 translate-middle badge rounded-pill bg-dark complexity-badge ${algorithm === key ? '' : 'opacity-0'}`}>
                                                {algoInfo[key].complexity}
                                            </span>
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="row g-4 mb-4">
                                <div className="col-lg-8">
                                    <VegaVisualization data={data} algorithm={algorithm} />
                                </div>
                                <div className="col-lg-4">
                                    <div className="card h-100 bg-dark bg-opacity-75 border-0">
                                        <div className="card-body">
                                            <h5 className="card-title text-white mb-3 d-flex justify-content-between align-items-center">
                                                <span>{algoInfo[algorithm].title}</span>
                                                {isSorting && (
                                                    <span className="badge bg-secondary d-flex align-items-center gap-1">
                                                        <span className="spinner-border spinner-border-sm" role="status"></span>
                                                        조율 중
                                                    </span>
                                                )}
                                            </h5>
                                            <div className="d-flex align-items-center mb-3 text-info">
                                                <i className="bi bi-stopwatch me-2"></i>
                                                <span className="fw-bold" style={{fontFamily: 'monospace'}}>{time.toFixed(2)} 초</span>
                                            </div>
                                            <p className="card-text text-secondary">{algoInfo[algorithm].concept}</p>
                                            <div className="mt-3">
                                                <small className="text-muted">복잡도: <span className="text-warning fw-bold">{algoInfo[algorithm].complexity}</span></small>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="d-flex align-items-center justify-content-center mb-3">
                                <span className="text-secondary me-2">속도:</span>
                                <input 
                                    type="range" 
                                    className="form-range mx-2" 
                                    style={{width: "150px"}}
                                    min="10" 
                                    max="150" 
                                    value={speed}
                                    onChange={e => setSpeed(parseInt(e.target.value))}
                                    disabled={isSorting}
                                />
                                <span className="text-info ms-2" style={{width: "40px"}}>{formatSpeed(speed)}</span>
                            </div>

                            <div className="d-flex justify-content-center gap-3">
                                <button 
                                    className={`btn ${isSorting ? 'btn-danger' : 'btn-primary'} d-flex align-items-center gap-2`}
                                    onClick={handleStartStop}
                                >
                                    {isSorting ? (
                                        <><i className="bi bi-pause-fill"></i> 중지</>
                                    ) : (
                                        <><i className="bi bi-play-fill"></i> 시작</>
                                    )}
                                </button>
                                <button 
                                    className="btn btn-secondary d-flex align-items-center gap-2" 
                                    onClick={handleReset}
                                    disabled={isSorting}
                                >
                                    <i className="bi bi-arrow-repeat"></i> 초기화
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            const container = document.getElementById('root');
            const root = ReactDOM.createRoot(container);
            root.render(<App />);
        }
        
        // 라이브러리 로드 확인
        let attempts = 0;
        const maxAttempts = 50;
        
        const readyCheck = setInterval(() => {
            attempts++;
            if (window.React && window.ReactDOM && window.ReactDOM.createRoot && window.vega) {
                clearInterval(readyCheck);
                runApp();
            } else if (attempts >= maxAttempts) {
                clearInterval(readyCheck);
                document.getElementById('root').innerHTML = `
                    <div class="alert alert-danger">
                        <h2>라이브러리 로드 중 오류가 발생했습니다</h2>
                        <p>페이지를 새로고침하거나 다른 브라우저에서 시도해 주세요.</p>
                    </div>
                `;
            }
        }, 100);
    </script>
    
    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
